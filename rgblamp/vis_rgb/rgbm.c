#include <math.h>
#include "rgbm.h"
#include "librgblamp.h"

/*
 * Static global variables
 */

static double binavg[3];
/* Set after successful PWM write, and enables rgb_matchpwm afterwards */
static int wrotepwm;

#ifdef RGBM_TESTSUM
static double testsum[RGBM_NUMBINS];
#endif

#if defined(RGBM_AUDACIOUS)
static const unsigned int bin_limits[3][2] = {
    /* Calibrated in Audacious 3.4 in Ubuntu 13.10, using
     * 44100 Hz samping rate pink noise generated by SoX v14.4.1.
     * Mono and stereo generated identical results.
     */
    { 0, 29 },
    { 30, 113 },
    { 114, 255 }
};
#endif

/*
 * Internal routines
 */

static void rgbm_sumbins(const RGBM_BINTYPE bins[RGBM_NUMBINS],
                         double sums[3],
                         const unsigned int limits[3][2]){
    int i = 0;
    for (i = 0; i < 3; i++) {
        int j, jend = limits[i][1];
        double sum = 0;

        for (j = limits[i][0]; j <= jend; j++) {
            sum += (double)bins[j];
        }
        sums[i] = sum;
    } /* for i */
} /* rgbm_sumbins */

static void rgbm_avgsums(const double sums[3],
                         double avg[3],
                         double scale,
                         double bound) {
    int i = 0;
    for (i = 0; i < 3; i++) {
        double avgsize, sum;

        sum = (double)sums[i] * scale;

        if (sum > avg[i]) {
            avgsize = RGBM_AVGUP;
        } else {
            avgsize = RGBM_AVGDN;
        }

        avg[i] = ((avgsize - 1.0) * avg[i] + sum) / avgsize;
        if (avg[i] > bound) avg[i] = bound;
    } /* for i */
} /* rgbm_avgsums */

#ifdef RGBM_TESTSUM
static void rgbm_testsum(const RGBM_BINTYPE bins[RGBM_NUMBINS]) {
    int i;
    for (i = 0; i < RGBM_NUMBINS; i++) {
        testsum[i] = (testsum[i] * 999.0 + (double)bins[i]) / 1000.0;
        fprintf(stderr, "%i:%f\n", i, testsum[i]);
    }
} /* rgbm_testsum */
#endif /* RGBM_TESTSUM */

/*
 * Interface routines
 */

int rgbm_init(void) {
    int i;

    if (!rgb_open(RGBPORT))
        return false;

    for (i = 0; i < 3; i++) binavg[i] = 0.0;
#ifdef RGBM_TESTSUM
    for (i = 0; i < RGBM_NUMBINS; i++) testsum[i] = 0.0;
#endif
    wrotepwm = 0;
    return true;
}

void rgbm_shutdown(void) {
    if (wrotepwm)
        rgb_matchpwm_srgb(binavg[0], binavg[1], binavg[2]);
    rgb_close();
}

int rgbm_render(const RGBM_BINTYPE bins[RGBM_NUMBINS]) {
    double sums[3];
    int res;

    rgbm_sumbins(bins, sums, bin_limits);
    rgbm_avgsums(sums, binavg, RGBM_SCALE, 1.0);
    rgb_flush();
#ifdef RGBM_TESTSUM
    rgbm_testsum(bins);
#endif
    /* printf("%9f, %9f, %9f\n", binavg[0], binavg[1], binavg[2]); */
    res = rgb_pwm_srgb(binavg[0], binavg[1], binavg[2]);
    if (res) wrotepwm = 1;
    return res;
} /* rgbm_render */
